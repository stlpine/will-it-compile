# Production values for will-it-compile
# This overrides default values for production deployment

replicaCount: 3

image:
  repository: stlpine/will-it-compile-api
  pullPolicy: IfNotPresent
  tag: ""  # Specify git SHA or semantic version at deploy time, never use 'latest'

# Official compiler images for production
compilerImages:
  gcc:
    repository: gcc
    tags: ["9-alpine", "11-alpine", "13-alpine"]
    pullPolicy: IfNotPresent
  go:
    repository: golang
    tags: ["1.22-alpine", "1.23-alpine"]
    pullPolicy: IfNotPresent
  rust:
    repository: rust
    tags: ["1.75-alpine", "1.80-alpine"]
    pullPolicy: IfNotPresent

serviceAccount:
  create: true
  annotations:
    # Add any cloud-specific annotations
    # iam.gke.io/gcp-service-account: will-it-compile@project.iam.gserviceaccount.com

podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8080"
  prometheus.io/path: "/metrics"

service:
  type: ClusterIP
  port: 80
  targetPort: 8080

ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
  hosts:
    - host: compile.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: will-it-compile-tls
      hosts:
        - compile.example.com

resources:
  limits:
    cpu: 2000m
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 512Mi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 20
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

networkPolicy:
  enabled: true
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
      ports:
        - protocol: TCP
          port: 8080
  egress:
    # DNS
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
        - podSelector:
            matchLabels:
              k8s-app: kube-dns
      ports:
        - protocol: UDP
          port: 53
    # Kubernetes API
    - to:
        - namespaceSelector: {}
      ports:
        - protocol: TCP
          port: 443
    # Redis communication (same namespace)
    - to:
        - podSelector:
            matchLabels:
              app.kubernetes.io/component: redis
      ports:
        - protocol: TCP
          port: 6379

podDisruptionBudget:
  enabled: true
  minAvailable: 2

# Production-specific affinity rules
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app
                operator: In
                values:
                  - will-it-compile
          topologyKey: kubernetes.io/hostname

# Node selector for dedicated nodes (optional)
# nodeSelector:
#   workload: compilation

# Tolerations for tainted nodes (optional)
# tolerations:
#   - key: "workload"
#     operator: "Equal"
#     value: "compilation"
#     effect: "NoSchedule"

# Redis Configuration (Production)
# Ephemeral in-memory cache - data lost on pod restart
redis:
  enabled: true
  image:
    repository: redis
    tag: "7-alpine"
    pullPolicy: IfNotPresent

  # Authentication - ENABLED for production
  auth:
    enabled: true
    password: ""  # Auto-generated on first install (store securely!)

  # Redis Configuration
  database: 0
  poolSize: 50  # Larger pool for production
  jobTTL: 48  # 48 hours for production (longer retention)
  maxMemory: "512mb"  # More memory for production
  maxMemoryPolicy: "allkeys-lru"

  # Resources - Production sizing
  resources:
    limits:
      cpu: 1000m
      memory: 1Gi
    requests:
      cpu: 250m
      memory: 512Mi

# Worker Pool Configuration (Production)
workerPool:
  enabled: true
  maxWorkers: 20  # More workers for production
  queueSize: 500  # Larger queue for production
